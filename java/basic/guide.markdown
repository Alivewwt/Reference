## 基础

### 面向过程

优点：性能高于面向对象。因为类调用时需要实例化，开销比较大，较消耗资源，所以当性能时最重要的考量因素的时候，比如单片机/嵌入式开发、Linux/Unix等一般采用面向过程开发。

缺点：没有 面向对象易维护、易复用、易扩展

### 面向对象

优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。

缺点：性能低于面向过程。

### JVM

Java虚拟机(JVM)是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现（Windows,Linux,MacOS），目的是使用相同的字节码，它们都会给出相同的结果。

什么是字节码？采用字节码的好处是什么？

>在java中，JVM可以理解的代码就叫做字节码（即扩展名为.class的文件），它不面向任何特定的处理器，只面向虚拟机。java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植性的特点。所以Java程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无需重新编译便可在多种不同操作系统的计算机上运行。

Java程序从源码到运行一般有下面3个步骤：

![1](/Users/wuwt/Desktop/1.png)

需要格外注意的是.class->机器码这一步，这一步中JVM类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块经常需要被调用的（也就是所谓的热点代码），所以后面引进了JIT编译器，而JIT属于运行时编译。当JIT编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。据我们所知，机器码的运行效率肯定高于Java解释器的，这也解释了我们常说的Java是编译与解释共存的语言。

总结：Java虚拟机(JVM)是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现(Windows,Linux,macOS)，目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的JVM实现时Java语言"一次编译，到处可以运行"的关键所在。

### JDK和JRE

JDK 是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器(javac)和工具(如javadoc和jdb)。它能够创建和编译程序。

JRE是Java运行时环境。它是运行已编译java程序所需的所有内容的集合，包括Java虚拟机(JVM)，java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。

### Oracle JDK 和OpenJDK的对比

关于JVM，JDK，JRE和OpenJDK之间的区别，下面一个帖子在2012年有一个更详细的答案：

>OpenJDK 存储库中的源代码与勇于构建Oracle JDK的代码之间有什么区别？
>
>非常接近-我们的Oracle JDK版本构建过程给予OpenJDK7构建，只添加了几个部分，例如，部署代码，其中包括Oracle的Java插件和Java Westart的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三方组件，如Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源Oracle JDK的所有部分。

总结：

1. Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；
2. OpenJDK是一个参考模型并且完全开源的，而 Oracle JDK 是open JDK的一个实现，并不是完全开源的；
3. Oracle JDK比OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎完全相同，但Oracle JDK有更多的类和修复一些错误。
4. 在响应性和JVM性能方面，OracleJDK与OpenJDK相比提供了更好的性能；
5. Oracle JDK不会为即将发布的版本提供长期支持，用户每次必须通过更新到最新版本支持获取最新版本；
6. Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL V2许可获得许可。

### Java和C++的区别

+ 都是面向对象语言，都支持封装、继承和多态
+ Java不提供指针来直接访问内存，程序内存更加安全
+ Java的类是单继承，C++支持多重继承；虽然Java类不可以多继承，但接口可以多继承
+ Java有自动内存管理机制，不需要程序员手动释放无用内存

### 字符型常量和字符串常量的区别

1. 形式上：字符常量是单引号引起的一个字符；字符串常量是双引号引起的若干个字符
2. 含义上：字符常量相当于一个整形值（ASCII值），可以参加表达式运算；字符串常量代表一个地址值（该字符串在内存中存放的位置）
3. 占内存大小：字符常量只占2个字符；字符串常量占若干个字节（至少一个字符结束标志）

![2](/Users/wuwt/Desktop/2.png)

### 构造器Constructor是否可被override?

在讲继承的时候，我们知道父类的私有属性和构造方法并不能被继承，所以Constructor也就不能被override（重写），但是overload (重载)，所以你可以看到一个类中有多个构造函数的情况。

### 重载和重写的区别

**重载**：发生同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。

**重写**：发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private 则子类就不能重写该方法。

### 三大特性

#### 封装

封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。

#### 继承

继承是使用已存在的类的定义作为基础建立新类的技术，新的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能给非常方便地复用以前的代码。

关于继承如下3点请记住

1. 子类拥有父类非private的属性和方法
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展
3. 子类可以用自己的方式实现父类的方法

#### 多态

所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。

### String、StringBuffer和StringBuilder

**可变性**

简单地来说：String类中使用final关键字修饰字符数组来保存字符串，private、final、char、value[]，所以String对象是不可变的。而StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串char[] value 但是没有用final关键字修饰，所以这两种对象都是可变的。

**线程安全性**

String中的对象是不可变的，也可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append和indexOf等公共方法。StringBuilder对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行同步锁，所以是非线程安全的。

**对于三者使用的总结**：

1. 操作少量的数据：适用String；
2. 单线程操作字符串缓冲区下操作大量数据：适用StringBuilder;
3. 多线程操作字符串缓冲区下操作大量数据：适用StringBuffer;

### 自动装箱和拆箱

**装箱**：将基本类型用它们对应的引用类型包装起来；

**拆箱**：将包装类型转换为基本数据类型。

### 在一个静态方法内调用一个非静态成员为什么是非法的？

由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。

### 在Java中定义一个不做事且没有参数的构造方法的作用

Java程序在执行子类的构造方法之前，如果没有用Super()来调用父类特定的构造方法，则会调用父类中"没有参数的构造方法"。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用Super()来调用父类中特定的构造方法，则在编译时发生错误，因为Java程序在父类中找不到没有参数的构造方法可以执行。解决办法是在父类中加一个不做事且没有参数的构造方法。

### 接口和抽象类

1. 接口的方法默认是public，所有方法在接口中不能有实现（java 8中可以有默认实现），而抽象类可以有非抽象的方法。
2. 接口中实例变量默认是final类型的，而抽象类则不一定。
3. 一个类可以实现多个接口，但最多只能实现一个抽象类。
4. 一个类实现接口的话要实现接口的所有方法，而抽象类不一定。
5. 接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象。从设计层面来看，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。

### 成员变量和局部变量

1. 从语法上来看：成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public、private、static等修饰符修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被final所修饰。
2. 从变量在内存的存储方法来看：如果成员变量是使用static修饰，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存中，局部变量则存在于栈内存中。
3. 从生存时间上看：成员变量是对象的一部分，它随对象的创建而存在，而局部变量随着方法的调用结束而自动消失。
4. 成员变量如过没有被赋予初值，则会自动以类型的默认值而赋值，而局部变量不会自动赋值。

### 构造方法的特性

1. 名字与类名相同
2. 没有返回值，但是不能用void声明构造函数
3. 生成类的对象时自动执行，无需调用

### hashcode与equals

首先提出一个问题："为什么重写equals时必须重写hashcode方法"？

#### hashCode()介绍

hashCode()的作用是获取哈希码，也称散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在JDK中Object.java中，这意味着Java中的任何类都包含有hashCode()函数。

#### 为什么要有hashCode

以hashSet为例说明：

当你把对象加入到hashSet时，hashSet会先计算对象的hashCode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，hashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals()方法来检查相等的对象是否真的相同。如果两者相同，hashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置，这样我们就大大减少了equals的次数，相应就大大提高了执行速度。

### java按值传递

按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用(call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。

**Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数数量的内容**。

### 线程、程序和进程的基本概念以及它们之间的关系

**线程**与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

**程序**是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。

**进程**是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建、运行到消亡的过程。简单地来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间、内存空间、文件，输入输出设备的使用权等等。换句话来说，当程序在执行时，将会被操作系统载入内存中。线程是进程划分成的更小运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。

### Java中的异常处理

在Java中，所有的异常都有一个共同的祖先java.lang包中的Throwable:有两个重要的子类：Exception(异常)和Error(错误)，二者都是Java异常处理的重要子类，各自包含大量子类。

**Error**(错误):是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。

这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。

**Exception**(异常)程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 异常由Java虚拟机抛出。**NullPointerException**（要访问的变量没有引用任何对象时，抛出该异常）、**ArithmeticException**（算术运算异常，一个整数除以0时，抛出该异常）和 **ArrayIndexOutOfBoundsException** （下标越界异常）。

**注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。**

#### 异常处理总结

+ try块：用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块
+ catch块:用于处理try捕获到的异常
+ finally块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。

在以下4种情况下，finally块不会被执行：

1. 在finally语句块第一行发生了异常。因为在其他行，finally块还是会得到执行
2. 在前面代码块种使用了system.exit(0)已退出程序
3. 程序所在的线程死亡
4. 关闭CPU

