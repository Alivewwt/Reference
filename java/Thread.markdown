### 线程和进程

#### 什么是线程和进程

进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。

在Java中，当我们启动main函数时其实就是启动可一个JVM的进程，而main函数所在的线程就是这个线程的一个线程，也称主线程。

#### 何为线程

线程与进程相似，但线程是一个比进程更小的执行单位。一个进行在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程由自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间切换工作时，负担要比进程小的多，也正因为如此，线程也被称为轻量级进程。

### 线程和进程的关系

线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程极有可能回相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。

#### 程序计数器为什么是私有的？

程序计数器的两个作用：

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行的位置。

程序计数器私有主要是**为了线程切换后能恢复到正确的执行位置**。

**虚拟机栈和本地方法栈为什么是私有的？**

+ 虚拟机栈：每个java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在java虚拟机中入栈和出栈的过程。
+ 本地方法栈：和虚拟机栈索所发挥的作用非常相似，区别是：虚拟机栈和虚拟机执行java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的native方法服务。在HotSpot虚拟机中和java虚拟机栈合二为一。

所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。

堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象（所有对象都在这里分配内存），方法区主要存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

### 并行和并发的区别

+ 并发：同一时间段，多个任务都在执行（单位时间不一定同时执行）
+ 并行：单位时间内，多个任务同时执行

### 为什么要使用多线程

总体上：

+ 从计算机底层上来说：线程可以比作是轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小于进程。另外，多核CPU时代意味着多个线程可以同时运行，这就减少了线程上下文切换的开销。
+ 从当代互联网发展趋势来说：现在的系统动不动就要百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。

再深入到计算机底层来探讨：

- **单核时代：** 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。
- **多核时代:** 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。

###  什么是上下文切换

多线程编程中一般线程的个数都大于CPU核心的个数，而一个CPU核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。

概括来说：当前任务在执行完CPU时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换。**

上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的CPU时间，事实上，可能是操作系统中时间消耗最大的操作。

### 什么是死锁

多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于现场被无限期地阻塞，因此程序不可能正常终止。

学过操作系统的朋友都知道产生死锁必须具备以下四个条件：

1. 互斥条件：该资源任意一个时刻只由一个线程占用。

2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放

3. 不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，至有自己使用完毕后才释放资源

4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

   

### 如何避免死锁

我们只需破坏产生死锁的四个条件中的其中一个就可以了。

#### 破坏互斥条件

这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。

#### 破坏请求与保持条件

一次性申请所有的资源。

#### 破坏不剥夺条件

占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。

#### 破坏循环等待条件

靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

### sleep()和wait()方法的区别和共同点

+ 两者最主要的区别在于：sleep方法没有释放锁,而wait方法释放了锁。
+ 两者都可以暂停线程的执行。
+ wait通常被用于线程间的通信/交互，sleep通常被用于暂停执行。
+ wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。

### 为什么调用start()方法会执行run()方法，为什么我们不能直接调用run()方法？

new一个Thread,线程进入了新建状态；调用start()方法，会启动一个线程并使用线程进入了就绪状态，当分配到时间片后就可以开始运行了。start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。而直接执行run()方法，会把run方法当成一个main线程下的普通方法执行，并不会在某个线程中执行它，所以这并不是多线程工作。

**总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。**





























